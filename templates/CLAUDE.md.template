# CLAUDE.md

This file provides comprehensive guidance to Claude Code and other LLM coding agents when working with Shiny-React applications.

## Project Overview

This is a Shiny-React application created from a template. Shiny-React is a React bindings library that enables bidirectional communication between React frontend components and Shiny servers (both R and Python), allowing you to build applications with React's frontend reactivity and Shiny's backend reactivity.

**Key Concept**: The frontend uses React's reactivity, and the backend uses Shiny's reactivity. These are both forms of reactivity, but they have differences from each other. Shiny-React bridges these two reactive systems.

**Architecture**:
- **Frontend**: React with TypeScript using shiny-react hooks
- **Backend**: Shiny server (both R and Python versions available)
- **Communication**: Bidirectional real-time data flow via shiny-react library
- **Build System**: Dual ESBuild bundling for both CommonJS and ESM compatibility

## Tools

You may have access to a shadcn/ui MCP server. If so, use it to find and install UI components.

## Directory Structure

```
{project_name}/
├── package.json            # Build configuration and npm dependencies
├── tsconfig.json           # TypeScript configuration
├── CLAUDE.md               # This file - instructions for LLM coding agents
├── srcts/                  # React TypeScript source code
│   ├── main.tsx            # React app entry point
│   ├── *.tsx               # React components using shiny-react hooks
│   └── styles.css/globals.css  # CSS styling
├── r/                      # R Shiny backend
│   ├── app.R               # Main R Shiny application
│   ├── shinyreact.R        # R functions for shiny-react
│   └── www/                # Built JavaScript/CSS output (auto-generated)
│       ├── main.js         # Compiled React code for R backend
│       └── main.css        # Compiled CSS for R backend
└── py/                     # Python Shiny backend
    ├── app.py              # Main Python Shiny application
    ├── shinyreact.py       # Python functions for shiny-react
    └── www/                # Built JavaScript/CSS output (auto-generated)
        ├── main.js         # Compiled React code for Python backend
        └── main.css        # Compiled CSS for Python backend
```

## Key Files and Their Purpose

### Frontend (React/TypeScript)
- **`srcts/main.tsx`**: Entry point that mounts the React app to the DOM
- **`srcts/*.tsx`**: React components using shiny-react hooks
- **`srcts/styles.css`**: Application styling

### Backend (Shiny)
- **`r/app.R`** or **`py/app.py`**: Main Shiny server application
- **`r/shinyreact.R`** or **`py/shinyreact.py`**: Utility functions for bare page setup and custom renderers
- **`r/www/`** or **`py/www/`**: Auto-generated build output (JavaScript and CSS bundles)

## Build Commands

### Development Workflow
```bash
# Install dependencies
npm install

# Development with hot reload (builds for both R and Python)
npm run watch

# One-time build (builds for both R and Python)
npm run build
```

## Running the Application

### Development Setup
1. **Start build watcher** (in one terminal):
   ```bash
   npm run watch
   ```

2. **Run Shiny server** (in another terminal):
   ```bash
   # For R backend
   R -e "options(shiny.autoreload = TRUE); shiny::runApp('r/app.R', port=8000)"

   # For Python backend
   shiny run py/app.py --port 8000 --reload
   ```

3. **Open browser**: Navigate to `http://localhost:8000`

## How Shiny-React Works

### Core Concepts
- **`useShinyInput<T>(id, defaultValue)`**: Sends data FROM React TO Shiny server
- **`useShinyOutput<T>(id, defaultValue)`**: Receives data FROM Shiny server TO React
- **Real-time bidirectional communication**: Changes in React trigger server updates, server responses update React UI

### Data Flow Pattern
```
React Component ──[useShinyInput]──> Shiny Server
                                           │
                                           ▼
                                    Process/Transform Data
                                           │
                                           ▼
React Component <──[useShinyOutput]── Shiny Server
```

### Code Examples

#### TypeScript Global Types

If you need to access `window.Shiny` directly in your components, add a triple-slash directive at the top of your file to import the global type definitions:

```typescript
/// <reference types="@posit/shiny" />
```

Or you can add the following to your `tsconfig.json`:

```json
{
  "compilerOptions": {
    "types": ["@posit/shiny"]
  }
}
```

This provides TypeScript with the global `Window.Shiny` interface without importing any runtime code or triggering ESLint unused import warnings.

#### React Component Pattern
```typescript
/// <reference types="@posit/shiny" />
import { useShinyInput, useShinyOutput } from "@posit/shiny-react";

function MyComponent() {
  // Send data to Shiny (like useState but syncs with server)
  const [inputValue, setInputValue] = useShinyInput<string>("my_input", "default");

  // Receive data from Shiny
  const [outputValue, outputRecalculating] = useShinyOutput<string>("my_output", undefined);

  return (
    <div>
      <input
        value={inputValue}
        onChange={(e) => setInputValue(e.target.value)}
      />
      <div>Server says: {outputValue}</div>
    </div>
  );
}
```

#### R Shiny Server Pattern
```r
server <- function(input, output, session) {
  output$my_output <- render_json({
    toupper(input$my_input)  # Transform the input
  })
}
```

#### Python Shiny Server Pattern
```python
def server(input, output, session):
    @render_json
    def my_output():
        return input.my_input().upper()  # Transform the input
```

## Common Development Tasks

### Adding a New Input/Output Pair
1. **In React component**: Add `useShinyInput` and `useShinyOutput` hooks
2. **In Shiny server**: Add corresponding input handler and output renderer
3. **Rebuild**: Run `npm run build` or use watch mode

### Adding New React Components
1. **Create component file** in `srcts/` directory
2. **Import and use** in main component or `main.tsx`
3. **Follow shiny-react patterns** for any Shiny communication
4. **Update styling** in `styles.css` if needed

### Modifying Backend Logic
- **R**: Edit `r/app.R` for server logic, `r/shinyreact.R` for utilities
- **Python**: Edit `py/app.py` for server logic, `py/shinyreact.py` for utilities
- **No rebuild needed** for backend changes (Shiny auto-reloads if configured)

## Architecture Details

### Build System
- **ESBuild**: Bundles React TypeScript code into JavaScript
- **Dual Output**: Creates separate bundles for R (`r/www/`) and Python (`py/www/`) backends
- **CSS Bundling**: Automatically includes CSS in JavaScript bundles
- **TypeScript Compilation**: Provides type checking during development

### Communication Layer
- **Debounced Updates**: Input changes debounced (default 100ms) to prevent excessive server calls
- **Event Priority System**: Bypass deduplication for event-style inputs like buttons
- **Promise-based Initialization**: Waits for Shiny to initialize before establishing connections
- **Custom Output Binding**: Extends Shiny's output system for React integration

## Troubleshooting

### Common Issues
1. **"Shiny not found" errors**: Ensure Shiny server is running and accessible
2. **Build failures**: Check that all dependencies are installed (`npm install`)
3. **Hot reload not working**: Restart watch mode (`npm run watch`)
4. **Data not syncing**: Verify matching input/output IDs between React and Shiny
5. **TypeScript errors**: Check type definitions and imports

### Development Tips
- **Use browser DevTools**: Check console for React/JavaScript errors
- **Monitor Shiny logs**: Watch R/Python console for server-side errors
- **Verify IDs match**: Input/output IDs must be identical in React and Shiny code
- **Check network tab**: Verify WebSocket communication between client and server

### Port Conflicts
If port 8000 is in use, change the port:
```bash
# R
R -e "shiny::runApp('r/app.R', port=8001)"

# Python
shiny run py/app.py --port 8001
```

## Testing Approach
- **Manual testing**: Run the app and verify input/output behavior
- **Browser testing**: Test in different browsers for compatibility
- **Network testing**: Monitor WebSocket connections in browser DevTools
- **Type checking**: Use `npm run watch` for continuous TypeScript validation

## File Extension Patterns
- **`.tsx`**: React components with JSX
- **`.ts`**: TypeScript utility files
- **`.css`**: Styling files
- **`.R`**: R Shiny server files
- **`.py`**: Python Shiny server files

## Key Dependencies
- **shiny-react**: Core library for React-Shiny communication
- **react + react-dom**: React framework
- **typescript**: TypeScript compiler and type checking
- **esbuild**: Fast JavaScript bundling

---

# Complete Shiny-React Library Documentation

## Core Shiny-React Concepts

### Reactivity Systems Bridge
Shiny-React connects two different reactivity systems:

**Frontend (React)**:
- React components use `useState` and other hooks for state management
- State changes trigger re-renders of components
- Changes flow through component trees via props and context

**Backend (Shiny)**:
- Shiny's reactivity system is a directed graph of reactive values and reactive functions
- Input values are reactive values that trigger re-execution of dependent functions when they change
- Output values are set by reactive functions that automatically re-execute when their inputs change

**The Bridge**:
- `useShinyInput` extends React state to the server (server can read, but not modify)
- `useShinyOutput` brings server reactive values into React components
- Communication happens via WebSocket with debouncing and deduplication

## Complete API Reference

### useShinyInput Hook

```typescript
function useShinyInput<T>(
  id: string,
  defaultValue: T,
  options?: {
    debounceMs?: number;
    priority?: EventPriority;
  }
): [T, (value: T) => void]
```

**Purpose**: Sends data FROM React TO Shiny server (similar to `useState` but syncs with server).

**Parameters**:
- `id`: The Shiny input ID (accessed as `input$id` in R or `input.id()` in Python)
- `defaultValue`: Initial value for the input
- `options.debounceMs`: Debounce delay in milliseconds (default: 100ms)
- `options.priority`: Event priority level - use `"event"` for button clicks to ensure reactive invalidation even with identical values

**Returns**: `[value, setValue]` tuple identical to React's `useState`

**Key Behaviors**:
- Values are debounced before sending to prevent excessive server calls
- Values are deduplicated (identical consecutive values are not sent, unless using `priority: "event"`)
- Event priority bypasses deduplication for cases like button clicks where identical values still need to trigger updates
- Waits for Shiny initialization before sending values
- Updates are sent to `ShinyReactRegistry` which manages server communication

**Example**: All input types from the 2-inputs example
```typescript
// Text input
const [textValue, setTextValue] = useShinyInput<string>("txtin", "Hello, world!");

// Number input with constraints
const [numberValue, setNumberValue] = useShinyInput<number>("numberin", 42);

// Boolean checkbox
const [checkboxValue, setCheckboxValue] = useShinyInput<boolean>("checkboxin", false);

// Radio button selection
const [radioValue, setRadioValue] = useShinyInput<string>("radioin", "option1");

// Select dropdown
const [selectValue, setSelectValue] = useShinyInput<string>("selectin", "apple");

// Slider/range input
const [sliderValue, setSliderValue] = useShinyInput<number>("sliderin", 50);

// Date input (HTML5 date picker)
const [dateValue, setDateValue] = useShinyInput<string>("datein", "2024-01-01");

// Button click with event priority (ensures reactive updates even with identical values)
const [buttonValue, setButtonValue] = useShinyInput<null | object>("buttonin", null, {
  debounceMs: 0,
  priority: "event"
});

// Slider with immediate updates (no debouncing)
const [sliderValue, setSliderValue] = useShinyInput<number>("sliderin", 50, {
  debounceMs: 0
});
```

### useShinyOutput Hook

```typescript
function useShinyOutput<T>(
  outputId: string,
  defaultValue?: T | undefined
): [T | undefined, boolean]
```

**Purpose**: Receives data FROM Shiny server TO React components.

**Parameters**:
- `outputId`: The Shiny output ID (set as `output$outputId` in R or `@render.type def outputId()` in Python)
- `defaultValue`: Optional default value before first server update

**Returns**: `[value, recalculating]` tuple where:
- `value`: Current value of the Shiny output (undefined until first update)
- `recalculating`: Boolean indicating if server is currently recalculating this output

**Example**: Various output types
```typescript
// Simple text output
const [textOutput, textOutputRecalc] = useShinyOutput<string>("txtout", undefined);

// Complex JSON data (from 3-outputs example)
const [tableData, tableDataRecalc] = useShinyOutput<Record<string, number[]>>("table_data", undefined);

// Statistics object
const [stats, statsRecalc] = useShinyOutput<{
  colname: string;
  mean: number;
  median: number;
  min: number;
  max: number;
}>("table_stats", undefined);

// Plot output
const [plotData, plotDataRecalc] = useShinyOutput<ImageData>("plot1", undefined);
```

### ImageOutput Component

```typescript
function ImageOutput({
  id,
  className
}: {
  id: string;
  className?: string;
}): JSX.Element
```

**Purpose**: Displays plot images from Shiny with automatic dimension tracking and progress indication.

**Features**:
- Automatically tracks image dimensions and sends to server via `.clientdata_output_${id}_width/height`
- Shows loading state while plots are being generated
- Handles image resize events with debounced dimension updates
- Supports opacity changes during recalculation

**Usage**:
```typescript
import { ImageOutput } from "@posit/shiny-react";

function PlotCard() {
  return (
    <div>
      <h2>My Plot</h2>
      <ImageOutput id="plot1" className="my-plot-styles" />
    </div>
  );
}
```

**Backend Requirements**:
```r
# R - Use renderPlot
output$plot1 <- renderPlot({
  # Your plotting code here
  plot(mtcars$wt, mtcars$mpg)
})
```

```python
# Python - Use render.plot
@render.plot()
def plot1():
    fig, ax = plt.subplots()
    ax.scatter(mtcars["wt"], mtcars["mpg"])
    return fig
```

## Advanced Patterns and Examples

### Complex Data Structures (from 3-outputs example)

**Data Table with Dynamic Columns**:
```typescript
function DataTableCard() {
  const [tableData] = useShinyOutput<Record<string, number[]> | undefined>(
    "table_data",
    undefined
  );

  // Extract column names dynamically from JSON structure
  const columnNames = tableData ? Object.keys(tableData) : [];
  const numRows = columnNames.length > 0 ? tableData![columnNames[0]].length : 0;

  return (
    <table>
      <thead>
        <tr>
          {columnNames.map(colName => (
            <th key={colName}>{colName.toUpperCase()}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {Array.from({ length: numRows }, (_, rowIndex) => (
          <tr key={rowIndex}>
            {columnNames.map(colName => {
              const value = tableData?.[colName][rowIndex];
              return (
                <td key={colName}>
                  {typeof value === "number"
                    ? Number.isInteger(value) ? value : value.toFixed(3)
                    : value}
                </td>
              );
            })}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

### Data Frame Serialization

When working with data frames (tables) in Shiny-React applications, it's important to understand how they are serialized between the server and client.

**Column-Major Format**: Data frames are serialized as JSON objects in **column-major format**, where each column becomes a property in the JSON object with an array of values:

```json
{
  "mpg": [21, 21, 22.8, 21.4, 18.7, ...],
  "cyl": [6, 6, 4, 6, 8, ...],
  "disp": [160, 160, 108, 258, 360, ...],
  "hp": [110, 110, 93, 110, 175, ...],
  ...
}
```

**Reading Data Frames in JavaScript**:
```typescript
// Receiving column-major data from server
const [tableData] = useShinyOutput<Record<string, number[]> | undefined>(
  "table_data",
  undefined
);

// Convert to row-major format for easier processing
function convertToRows(columnData: Record<string, any[]>): any[] {
  const columnNames = Object.keys(columnData);
  const numRows = columnNames.length > 0 ? columnData[columnNames[0]].length : 0;

  return Array.from({ length: numRows }, (_, rowIndex) => {
    const row: Record<string, any> = {};
    columnNames.forEach(colName => {
      row[colName] = columnData[colName][rowIndex];
    });
    return row;
  });
}

// Usage in component
function DataTableCard() {
  const [tableData] = useShinyOutput<Record<string, number[]> | undefined>(
    "table_data",
    undefined
  );

  // Extract column names and data
  const columnNames = tableData ? Object.keys(tableData) : [];
  const numRows = columnNames.length > 0 ? tableData![columnNames[0]].length : 0;

  return (
    <table>
      <thead>
        <tr>
          {columnNames.map(colName => (
            <th key={colName}>{colName.toUpperCase()}</th>
          ))}
        </tr>
      </thead>
      <tbody>
        {Array.from({ length: numRows }, (_, rowIndex) => (
          <tr key={rowIndex}>
            {columnNames.map(colName => {
              const value = tableData?.[colName][rowIndex];
              return (
                <td key={colName}>
                  {typeof value === "number"
                    ? Number.isInteger(value) ? value : value.toFixed(3)
                    : value}
                </td>
              );
            })}
          </tr>
        ))}
      </tbody>
    </table>
  );
}
```

**Server-Side Data Frame Handling**:

*R Backend*:
```r
# Data frames are automatically converted to column-major JSON
output$table_data <- render_json({
  req(input$table_rows)
  # This will be converted to a JSON object in column-major format, as in:
  # {
  #   "mpg": [21, 21, 22.8, ...],
  #   "cyl": [6, 6, 4, ...],
  #   "disp": [160, 160, 108, ...],
  #   ...
  # }
  mtcars[seq_len(input$table_rows), ]
})
```

*Python Backend*:
```python
@render_json
def table_data():
    num_rows = input.table_rows()
    # This produces a JSON object in column-major format, as in:
    # {
    #   "mpg": [21, 21, 22.8, ...],
    #   "cyl": [6, 6, 4, ...],
    #   "disp": [160, 160, 108, ...],
    #   ...
    # }
    return mtcars.head(num_rows).to_dict(orient="list")
```

### Custom Renderers for Complex Data

 In shinyreact.R and shinyreact.py, there is a `render_json()` function that can be used to send arbitrary data to the frontend as JSON. This function is used widely for sending  data structures to the frontend.

**R Backend - render_json**:
```r
# In app.R
output$table_stats <- render_json({
  mpg_subset <- mtcars$mpg[seq_len(input$table_rows)]
  list(
    colname = "mpg",
    mean = mean(mpg_subset),
    min = min(mpg_subset),
    max = max(mpg_subset)
  )
})
```

**Python Backend - render_json**:
```python
# In app.py
@render_json
def table_stats():
    num_rows = input.table_rows()
    mpg_subset = mtcars["mpg"][seq_len(num_rows)]
    return {
        "colname": "mpg",
        "mean": float(mpg_subset.mean()),
        "min": float(mpg_subset.min()),
        "max": float(mpg_subset.max()),
    }
```

## Input Component Patterns

### Button Input Pattern (Event Handling with Event Priority)
```typescript
// Use priority: "event" to ensure each button click triggers server updates
// even though we send the same empty object value each time
const [buttonValue, setButtonValue] = useShinyInput<null | object>(
  "buttonin",
  null,
  {
    debounceMs: 0,      // No delay for button clicks
    priority: "event"   // Bypass deduplication for event-style inputs
  }
);

const handleButtonClick = () => {
  setButtonValue({});  // Send empty object - value doesn't matter for events
};

return (
  <div>
    <button onClick={handleButtonClick}>Click Me</button>
    <div>Button sends: {JSON.stringify(buttonValue)}</div>
    <div>
      Note: useShinyInput is called with priority:"event" so that even
      though the value (an empty object) is sent every time the button is
      clicked, it will still cause reactive invalidation on the server.
    </div>
  </div>
);
```

### Date Input Pattern
```typescript
// Default to today's date in YYYY-MM-DD format
const today = new Date().toISOString().split('T')[0];
const [dateValue, setDateValue] = useShinyInput<string>("datein", today);

return (
  <div>
    <input
        type="date"
        value={dateValue}
        onChange={(e) => setDateValue(e.target.value)}
      />
  </div>
);
```

### Radio Button Group Pattern
```typescript
const [radioValue, setRadioValue] = useShinyInput<string>("radioin", "option1");
const options = ["option1", "option2", "option3"];

return (
  <div className="radio-group">
    {options.map(option => (
      <label key={option}>
        <input
          type="radio"
          name="radio-options"
          value={option}
          checked={radioValue === option}
          onChange={(e) => setRadioValue(e.target.value)}
        />
        {option}
      </label>
    ))}
  </div>
);
```

### File Input Pattern with Drag-and-Drop

File inputs require special handling since Shiny needs access to actual file objects, not just filenames. The key is to use a **hidden HTML file input** that Shiny can automatically detect and bind to, combined with React state for UI interactions:

```typescript
const inputRef = useRef<HTMLInputElement>(null);
const [files, setFiles] = useState<File[]>([]);
const [isDragOver, setIsDragOver] = useState(false);

const handleFiles = (files: FileList | null) => {
  if (files) {
    const fileArray = Array.from(files);
    setFiles(fileArray);
  } else {
    setFiles([]);
  }
};

const handleInputChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  handleFiles(event.target.files);
};

const handleButtonClick = () => {
  inputRef.current?.click();
};

const handleDragOver = (event: React.DragEvent) => {
  event.preventDefault();
  setIsDragOver(true);
};

const handleDragLeave = (event: React.DragEvent) => {
  event.preventDefault();
  setIsDragOver(false);
};

const handleDrop = (event: React.DragEvent) => {
  event.preventDefault();
  setIsDragOver(false);
  handleFiles(event.dataTransfer.files);
};

return (
  <div>
    {/*
      Hidden file input - Shiny automatically detects this and creates a
      corresponding Shiny input with the same name as the id.
    */}
    <input
      ref={inputRef}
      type="file"
      id="filein"
      multiple={true}
      onChange={handleInputChange}
      style={{ display: "none" }}
    />

    {/* Custom drag and drop area */}
    <div
      className={`file-drop-zone ${isDragOver ? "drag-over" : ""}`}
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
      onClick={handleButtonClick}
    >
      <div className="file-drop-content">
        {files.length === 0 ? (
          <>
            <div className="file-drop-text">
              Click to select files or drag and drop them here
            </div>
            <div className="file-drop-hint">Multiple files are supported</div>
          </>
        ) : (
          <div className="selected-files">
            <ul className="selected-files-list">
              {files.map((file, index) => (
                <li key={index}>
                  {file.name} ({Math.round(file.size / 1024)} KB)
                </li>
              ))}
            </ul>
            <div className="file-drop-hint">
              Click to select different files or drag new ones here
            </div>
          </div>
        )}
      </div>
    </div>
  </div>
);
```

**Key File Input Concepts**:

1. **Hidden HTML Input**: The actual `<input type="file">` must be present for Shiny to detect and bind to it. The `id` attribute becomes the Shiny input name (`input$filein` in R or `input.filein()` in Python).

2. **React State Management**: Use `useState` to track selected files for UI display, but the actual file data is handled by Shiny's input binding.

3. **Custom UI Layer**: Build a custom drag-and-drop interface while keeping the hidden HTML input for Shiny compatibility.

4. **File List Display**: Show selected files with names and sizes for user feedback.

**Backend File Handling**:

*R Backend*:
```r
server <- function(input, output, session) {
  output$fileout <- render_json({
    req(input$filein)

    files_info <- input$filein
    # files_info is a data frame with columns: name, size, type, datapath

    file_details <- paste(
      paste("File:", files_info$name, collapse = "\n"),
      paste("Size:", files_info$size, "bytes", collapse = "\n"),
      paste("Type:", files_info$type, collapse = "\n"),
      paste("Path:", files_info$datapath, collapse = "\n"),
      sep = "\n"
    )

    # Read file content example
    if (nrow(files_info) > 0) {
      first_file_content <- readLines(files_info$datapath[1], n = 5)
      paste(file_details, "\nFirst 5 lines:", paste(first_file_content, collapse = "\n"))
    } else {
      file_details
    }
  })
}
```

*Python Backend*:
```python
def server(input: Inputs, output: Outputs, session: Session):
    @render_json
    def fileout():
        file_infos = input.filein()
        if not file_infos:
            return "No files selected"

        # file_infos is a list of FileInfo objects
        details = []
        for file_info in file_infos:
            details.append(f"File: {file_info['name']}")
            details.append(f"Size: {file_info['size']} bytes")
            details.append(f"Type: {file_info['type']}")

            # Read file content example
            with open(file_info['datapath'], 'r') as f:
                first_lines = [f.readline().strip() for _ in range(5)]
                details.append(f"First 5 lines: {' | '.join(first_lines)}")

        return "\n".join(details)
```

**File Input Best Practices**:
- Always use `req(input$filein)` in R or check for null in Python before processing files
- Display file information for user
- If `multiple` is set to true, handle multiple files by iterating over the file list
- Use `datapath` property to access the uploaded file content
- Consider file size limits and validation on the server side
- Provide clear visual feedback during drag-and-drop operations

### Compound Input Pattern (Batch Form Submission)

Compound inputs collect multiple form fields in **local React state** and only send data to Shiny when the user explicitly submits (e.g., button click). This pattern reduces server calls and provides better UX for complex forms.

```typescript
const [comment, setComment] = useState("");
const [priority, setPriority] = useState(50);
const [features, setFeatures] = useState({ notifications: false, darkMode: false });

// Single Shiny input for batch submission
const [formData, setFormData] = useShinyInput<object | null>(
  "formdata",
  null,
  { debounceMs: 0, priority: "event" }
);

const handleSubmit = () => {
  const data = { comment, priority, features };
  setFormData(data);  // Send all data at once
};

return (
  <div>
    <textarea value={comment} onChange={(e) => setComment(e.target.value)} />
    <input
      type="range"
      value={priority}
      onChange={(e) => setPriority(Number(e.target.value))}
    />
    <label>
      <input
        type="checkbox"
        checked={features.notifications}
        onChange={(e) => setFeatures(prev => ({...prev, notifications: e.target.checked}))}
      />
      Enable Notifications
    </label>
    <button onClick={handleSubmit}>Submit Form</button>
  </div>
);
```

**Backend Handling**:

These examples just send the form data back to the UI for display. In a real application, you would do something with the data.

*R Backend*:
```r
output$formout <- render_json({
  data <- input$formdata
  if (is.null(data)) return("No data submitted yet.")

  data$receivedAt <- as.character(Sys.time())
  jsonlite::toJSON(data, auto_unbox = TRUE, pretty = TRUE)
})
```

*Python Backend*:
```python
@render_json
def formout():
    data = input.formdata()
    if not data:
        return "No data submitted yet."

    data["receivedAt"] = datetime.datetime.now().isoformat()
    return json.dumps(data, indent=2)
```

**Key Concepts**:
- **Local State**: Form fields use `useState` - changes don't trigger server calls
- **Batch Submission**: Single `useShinyInput` collects all form data on submit
- **Event Priority**: Use `priority: "event"` so identical submissions still trigger server updates
- **Validation**: Disable submit button based on form validity

**When to Use Compound Inputs**:
- Complex forms with multiple related fields
- Forms where partial data isn't useful to the server
- Reducing server load by avoiding updates on every keystroke
- When you need client-side validation before submission

## Debouncing and Event Priority

### Understanding Debouncing

**Debouncing** delays sending input values to the Shiny server to prevent excessive server calls during rapid user interactions. By default, `useShinyInput` debounces updates by 100ms.

**When to Use Debouncing**:
- **Text inputs**: Prevent server calls on every keystroke
- **Sliders**: Reduce server load during dragging
- **Any high-frequency input**: Optimize performance for rapid value changes

**When to Disable Debouncing (`debounceMs: 0`)**:
- **Button clicks**: Users expect immediate response
- **Sliders where immediate feedback is important**: Real-time visualization
- **Form submissions**: No delay wanted for user actions

```typescript
// Default debouncing (100ms) - good for text inputs
const [text, setText] = useShinyInput<string>("text_input", "");

// No debouncing - immediate updates for sliders
const [slider, setSlider] = useShinyInput<number>("slider_input", 50, {
  debounceMs: 0
});

// Custom debouncing - longer delay for expensive operations
const [expensiveInput, setExpensiveInput] = useShinyInput<string>("expensive", "", {
  debounceMs: 500  // Wait 500ms before sending
});
```

### Understanding Event Priority

**Event Priority** controls how Shiny handles duplicate values. Normally, Shiny deduplicates consecutive identical values to avoid unnecessary reactive updates.

**Normal Priority (default)**:
- Values are compared and deduplicated
- `setValue(5)` followed by `setValue(5)` only triggers one server update
- Good for most inputs like text, sliders, dropdowns

**Event Priority (`priority: "event"`)**:
- Bypasses deduplication completely
- Every call to `setValue()` triggers a server update, even with identical values
- Essential for button clicks and event-like interactions

```typescript
// Normal priority - deduplicates identical values
const [count, setCount] = useShinyInput<number>("counter", 0);

// Event priority - every button click triggers server update
const [buttonEvent, setButtonEvent] = useShinyInput<object>("button_click", {}, {
  priority: "event",
  debounceMs: 0
});
```

### Button Click Pattern with Event Priority

Buttons require special handling because users expect each click to register, even if the "value" doesn't change:

```typescript
function EventButton() {
  // Send empty object with event priority - the value doesn't matter
  const [buttonClick, setButtonClick] = useShinyInput<null | object>(
    "button_input",
    null,
    {
      debounceMs: 0,       // Immediate response
      priority: "event"    // Every click triggers server update
    }
  );

  const clickCount = useShinyOutput<number>("click_count", 0);

  return (
    <div>
      <button onClick={() => setButtonClick({})}>
        Click Me
      </button>
      <p>Clicked {clickCount} times</p>
    </div>
  );
}
```

**Server-side button handling**:
```r
# R - Track button clicks by counting non-null values
num_button_clicks <- 0
output$click_count <- render_json({
  if (is.null(input$button_input)) {
    return(0)
  }
  num_button_clicks <<- num_button_clicks + 1
  num_button_clicks
})
```

```python
# Python - Track button clicks
num_button_clicks = 0

@render_json
def click_count():
    if input.button_input() is None:
        return "0"
    global num_button_clicks
    num_button_clicks += 1
    return str(num_button_clicks)
```

### Debouncing Best Practices

**Text Input with Debouncing**:
```typescript
// Good for search boxes - don't search on every keystroke
const [searchTerm, setSearchTerm] = useShinyInput<string>("search", "", {
  debounceMs: 300  // Wait for user to pause typing
});
```

**Slider with Immediate Updates**:
```typescript
// Good for real-time charts - show changes immediately
const [chartValue, setChartValue] = useShinyInput<number>("chart_param", 50, {
  debounceMs: 0  // Immediate updates for smooth interaction
});
```

**Performance Considerations**:
- **Too low debounce**: Server overload from rapid updates
- **Too high debounce**: UI feels unresponsive
- **Sweet spot**: 100-300ms for most text inputs, 0ms for buttons and real-time controls

## Server-to-Client Messages

The server can send **custom messages** directly to React components for notifications, real-time updates, and server-initiated events.

### Client-Side Message Handling

Register message handlers in React components using `window.Shiny.addCustomMessageHandler`:

```typescript
import React, { useState, useEffect } from "react";

function App() {
  const [toasts, setToasts] = useState<Array<{id: number, message: string, type: string}>>([]);

  useEffect(() => {
    const handleLogEvent = (msg: { message: string; type: string }) => {
      const newToast = { id: Date.now(), message: msg.message, type: msg.type };
      setToasts(prev => [...prev, newToast]);

      // Auto-remove after 6 seconds
      setTimeout(() => {
        setToasts(prev => prev.filter(toast => toast.id !== newToast.id));
      }, 6000);
    };

    window.Shiny.addCustomMessageHandler("logEvent", handleLogEvent);
  }, []);

  return (
    <div className="toast-container">
      {toasts.map(toast => (
        <div key={toast.id} className={`toast toast-${toast.type}`}>
          {toast.message}
        </div>
      ))}
    </div>
  );
}
```

### Server-Side Message Sending

**R Shiny**:
```r
session$sendCustomMessage("logEvent", list(
  message = "User logged in",
  type = "info"
))
```

**Python Shiny**:
```python
await session.send_custom_message("logEvent", {
    "message": "User logged in",
    "type": "info"
})
```

### Use Cases
- **Notifications**: Toast messages, alerts
- **Progress**: Long-running task updates
- **Real-time data**: Server-initiated data streams
- **System events**: Status changes, heartbeats

**Note**: Custom messages are server→client only and bypass the normal input/output reactive system.


## Client-to-Server Messages

As of now, there isn't a straightforward API to send one-way messages from the client to the server. One way to accomplish this is to use `useShinyInput` hook with `priority: "event"` and `debounceMs: 0`.


### Client-Side Message Sending

```typescript
const [_, setInfoMessage] = useShinyInput<object>("info_message", null, {
    priority: "event",
    debounceMs: 0
});


// Send message to server
setInfoMessage({ size: 3, quantity: 12 });
```

### Server-Side Message Handling

**R Shiny**:
```r
observeEvent(input$info_message, {
  req(input$info_message)
  # Print the message to the console
  cat("Info message received: ", input$info_message())
})
```

**Python Shiny**:
```python
@observe_event
async def info_message():
    req(input.info_message)
    # Print the message to the console
    print("Info message received: ", input.info_message())
```

## Backend Patterns and Best Practices

### R Shiny Patterns

**Basic Server Structure**:
```r
library(shiny)
source("shinyreact.R", local = TRUE)

# Using the page_react() convenience function (recommended)
ui <- page_react(title = "My Shiny React App")

server <- function(input, output, session) {
  # Text output - simple transformation
  output$txtout <- render_json({
    toupper(input$txtin)
  })

  # Complex data output using render_json
  output$table_data <- render_json({
    req(input$table_rows)  # Ensure input exists
    mtcars[seq_len(input$table_rows), ]
  })

  # Plot output
  output$plot1 <- renderPlot({
    req(input$table_rows)
    plot(mtcars$wt[1:input$table_rows], mtcars$mpg[1:input$table_rows])
  })
}

shinyApp(ui = ui, server = server)
```

**R Utility Functions (shinyreact.R)**:
```r
# Convenience function for React apps
page_react <- function(
  ...,
  title = NULL,
  js_file = "main.js",
  css_file = "main.css",
  lang = "en"
) {
  ...
}

# Custom renderer for arbitrary JSON data
render_json <- function(expr, env = parent.frame(), quoted = FALSE, outputArgs = list()) {
  ...
}
```

### Python Shiny Patterns

**Basic Server Structure**:
```python
from shiny import App, Inputs, Outputs, Session, ui, render
from shinyreact import page_react, render_json
from pathlib import Path

def server(input: Inputs, output: Outputs, session: Session):
    # Text output - simple transformation
    @render_json
    def txtout():
        return input.txtin().upper()

    # Complex data output using render_json
    @render_json
    def table_data():
        num_rows = input.table_rows()
        return mtcars.head(num_rows).to_dict(orient="list")

    # Plot output using matplotlib
    @render.plot()
    def plot1():
        num_rows = input.table_rows()
        fig, ax = plt.subplots()
        ax.scatter(mtcars["wt"].head(num_rows), mtcars["mpg"].head(num_rows))
        return fig

# Use the page_react() convenience function (recommended)
app = App(
  page_react(title="My Shiny React App"),
  server,
  static_assets=str(Path(__file__).parent / "www")
)
```

**Python Utility Functions (shinyreact.py)**:
```python
# Convenience function for React apps (recommended)
def page_react(
    *args: ui.TagChild,
    title: str | None = None,
    js_file: str | None = "main.js",
    css_file: str | None = "main.css",
    lang: str = "en",
) -> ui.Tag:
    ...

# Custom renderer for arbitrary JSON data
class render_json(Renderer[Jsonifiable]):
    """
    Reactively render arbitrary JSON object.

    This is a generic renderer that can be used to render any Jsonifiable data.
    It sends the data to the client-side and let the client-side code handle the
    rendering.
    """
    ...
```


### Reactivity Patterns

Shiny's reactivity is a **directed acyclic graph (DAG)** that automatically tracks dependencies and propagates changes through your application. Understanding this system is crucial for building efficient Shiny-React applications.

#### The Reactive Graph Structure

The reactive graph consists of three types of nodes:

1. **Reactive Values (Sources)** → 2. **Reactive Expressions/Calcs (Optional Middle)** → 3. **Observers/Effects/Renderers (Endpoints)**

```
[Input Values] → [Reactive Expressions] → [Outputs/Effects]
     ↓                    ↓                      ↓
(User changes)    (Cached calculations)   (UI updates/Side effects)
```

#### Reactive Values (Sources)

Reactive values are the **sources** of reactivity. They trigger the reactive chain when their values change.

**Types of Reactive Values**:
- **Shiny Inputs**: All `input$*` values from the UI (automatically reactive)
- **ReactiveValues** (R) / **reactive.value** (Python): Custom reactive values you create

**R Example**:
```r
# Custom reactive value
counter <- reactiveVal(0)

# This observer will invalidate and re-execute every time input$txt
# or counter() changes.
observe({
  cat(input$txt)
  cat(counter())
})

# observeEvent() is like observe(), but here it only is invalidated
# by input$txt. This example also sets counter() to a new value, which
# invalidates anything that depends on counter().
observeEvent(input$txt, {
  counter(counter() + 1)  # This triggers reactivity
})
```

**Python Example**:
```python
# Custom reactive value
counter = reactive.value(0)

# This effect will invalidate and re-execute every time input.txt()
# or counter() changes.
@reactive.effect
def _():
    print(input.txt())
    print(counter())

# With reactive.event(), this effect is only invalidated by input.txt().
# This example also sets counter() to a new value, which invalidates
# anything that depends on counter().
@reactive.effect
@reactive.event(input.txt)
def _():
    counter.set(counter() + 1)  # This triggers reactivity
```

**Key Behavior**: When a reactive value changes, all downstream reactive functions that depend on it are **invalidated** and scheduled for re-execution.

#### Reactive Expressions/Calcs (Intermediate Computations)

Reactive expressions (`reactive()` in R, `@reactive.calc` in Python) are **cached computations** that sit between reactive values and endpoints.

**Purpose**: Perform calculations that multiple outputs depend on, avoiding redundant computation.

**R Example**:
```r
# Reactive expression that filters data based on input
filtered_data <- reactive({
  # This uses input$min, so it will be invalidated when input$min changes.
  mtcars[mtcars$mpg >= input$min, ] # Result is cached
})

# Multiple outputs can use the same reactive expression
output$plot <- renderPlot({
  plot(filtered_data()$wt, filtered_data()$mpg)
})

output$summary <- render_json({
  paste("Rows:", nrow(filtered_data()))  # Uses cached value
})
```

**Python Example**:
```python
# Reactive calc that filters data based on input
@reactive.calc
def filtered_data():
    # This uses input.min, so it will be invalidated when input.min changes.
    return mtcars[mtcars["mpg"] >= input.min()]  # Result is cached

# Multiple outputs can use the same reactive calc
@render.plot
def plot():
    data = filtered_data()  # Uses cached value
    return plt.scatter(data["wt"], data["mpg"])

@render_json
def summary():
    return f"Rows: {len(filtered_data())}"  # Uses cached value
```

**Important Characteristics**:
- Results are **cached** - only re-compute when dependencies change
- **Should NOT have side effects** - use observers/effects for that
- **Lazy evaluation** - only execute when called by an endpoint
- Create dependencies when they access reactive values

#### Observers/Effects/Renderers (Endpoints)

These are the **endpoints** of the reactive chain where actions happen.

**Types**:

1. **Observers/Effects**: For side effects (file writes, logs, messages)
2. **Renderers**: For sending data to the UI (wrapped observers)

**R Observer Example**:
```r
# Observer for side effects
observe({
  # This re-runs whenever input$save_data changes
  req(input$save_data)

  # Side effect: write to file
  write.csv(filtered_data(), "output.csv")
  cat("Data saved at", Sys.time(), "\n")

  # Return value is ignored
})

# observeEvent for specific triggers
observeEvent(input$send_message, {
  session$sendCustomMessage("notification", list(
    message = paste("Button clicked at", Sys.time())
  ))
})
```

**Python Effect Example**:
```python
# Effect for side effects
@reactive.effect
def _():
    if input.save_data():
        # Side effect: write to file
        filtered_data().to_csv("output.csv")
        print(f"Data saved at {datetime.now()}")

    # Return value is ignored

# Event-based effect
@reactive.effect
@reactive.event(input.send_message)
async def _():
    await session.send_custom_message("notification", {
        "message": f"Button clicked at {datetime.now()}"
    })
```

**Renderer Example**:
```r
# Renderers are observers that send output to UI
output$result <- render_json({
  # Takes dependencies on any reactive values used
  paste("Value:", input$text_input, "Count:", values$counter)
})  # Return value is sent to client
```

**Key Behaviors**:
- **Eager execution**: Run automatically when invalidated
- **Auto-dependency tracking**: Dependencies determined at runtime
- **Re-execution on invalidation**: Scheduled to run when dependencies change

#### Important Anti-Patterns to Avoid

**1. Nested Reactive Objects**:
```r
# ❌ BAD: Don't define reactive objects inside others
observe({
  output$nested <- render_json({  # Don't do this!
    "This is wrong"
  })
})

# ✅ GOOD: Define at top level
output$proper <- render_json({
  "This is correct"
})
```

**2. Circular Dependencies**:
```r
# ❌ BAD: Can create infinite loops
values <- reactiveValues(a = 1, b = 2)

observe({
  values$a <- values$b + 1  # a depends on b
})

observe({
  values$b <- values$a + 1  # b depends on a - CIRCULAR!
})

# ✅ GOOD: Use reactive expressions for derived values
values <- reactiveValues(base = 1)

derived <- reactive({
  values$base * 2
})
```

**3. Side Effects in Reactive Expressions**:
```r
# ❌ BAD: Don't have side effects in reactive expressions
bad_reactive <- reactive({
  data <- read.csv("file.csv")
  write.csv(data, "output.csv")  # Side effect - DON'T DO THIS!
  return(data)
})

# ✅ GOOD: Use observers for side effects
good_reactive <- reactive({
  read.csv("file.csv")  # Pure computation
})

observe({
  write.csv(good_reactive(), "output.csv")  # Side effect in observer
})
```

#### Reactive Value Feedback Loops

Sometimes observers need to update reactive values, creating feedback loops. While valid, use sparingly:

```r
# Counter that auto-increments (use with caution)
values <- reactiveValues(counter = 0)

observe({
  invalidateLater(1000)  # Re-run every second
  isolate({  # Prevent taking dependency on values$counter
    values$counter <- values$counter + 1  # Updates reactive value
  })
})

# Better approach: Use reactive.poll or invalidateLater with clear purpose
```

**Best Practices**:
- Keep reactive graphs simple and acyclic
- Use reactive expressions for shared computations
- Reserve observers/effects for side effects only
- Avoid updating reactive values from observers when possible
- Use `req()` (R) or conditional checks (Python) to handle missing inputs gracefully


## Conclusion

This comprehensive documentation covers all aspects of Shiny-React development from basic concepts to advanced patterns and troubleshooting. Use it as a complete reference for building applications with React frontends and Shiny backends.
